To implement the GPTNutriCount Photo Selector, we will need the following core classes, functions, and methods:

- `main.py`: The entry point of the application, handling command-line arguments and orchestrating the photo selection process.
- `photo_finder.py`: Contains the `PhotoFinder` class to search for photos in the specified directory and filter them by creation date.
- `image_converter.py`: Contains the `ImageConverter` class to convert non-supported image formats to JPEG.
- `image_processor.py`: Contains the `ImageProcessor` class to copy or convert images to the target directory.
- `openai_client.py`: Contains the `OpenAIClient` class to interact with the OpenAI API for image analysis.
- `prompt_loader.py`: Contains the `PromptLoader` class to load the prompt from a text file.
- `file_utils.py`: Contains utility functions for file operations such as copying and deleting files.
- `requirements.txt`: Lists all the Python package dependencies for the project.

Let's start with the entry point of the application:

main.py
```python
import argparse
import os
from datetime import datetime
from photo_finder import PhotoFinder
from image_processor import ImageProcessor
from openai_client import OpenAIClient
from prompt_loader import PromptLoader

def main(input_folder, target_folder, date, prompt_file):
    # Load the prompt
    prompt = PromptLoader.load_prompt(prompt_file)

    # Initialize the OpenAI client
    openai_client = OpenAIClient(prompt)

    # Find photos
    photo_finder = PhotoFinder(input_folder, date)
    photos = photo_finder.find_photos()

    # Process images
    image_processor = ImageProcessor(target_folder, date)
    image_processor.process_images(photos, openai_client)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="GPTNutriCount Photo Selector")
    parser.add_argument("input_folder", help="The folder where photos are located")
    parser.add_argument("target_folder", help="The folder where selected photos will be stored")
    parser.add_argument("--date", help="The date for which to find photos (YYYY-MM-DD). Defaults to today's date.", default=datetime.now().strftime("%Y-%m-%d"))
    parser.add_argument("--prompt_file", help="The file containing the prompt for OpenAI API", default="nutricount-photo-select-prompt.txt")
    args = parser.parse_args()

    main(args.input_folder, args.target_folder, args.date, args.prompt_file)
```

Now, let's create the `PhotoFinder` class:

photo_finder.py
```python
import os
from datetime import datetime

class PhotoFinder:
    def __init__(self, directory, date_str):
        self.directory = directory
        self.date = datetime.strptime(date_str, "%Y-%m-%d").date()

    def find_photos(self):
        photos = []
        for root, _, files in os.walk(self.directory):
            for file in files:
                file_path = os.path.join(root, file)
                creation_date = datetime.fromtimestamp(os.path.getctime(file_path)).date()
                if creation_date == self.date:
                    photos.append(file_path)
        return photos
```

Next, we need the `ImageConverter` class:

image_converter.py
```python
from PIL import Image
import os

class ImageConverter:
    @staticmethod
    def convert_to_jpeg(image_path, output_path):
        with Image.open(image_path) as img:
            rgb_im = img.convert('RGB')
            rgb_im.save(output_path, 'JPEG')
```

The `ImageProcessor` class will use the `ImageConverter`:

image_processor.py
```python
import os
import shutil
from image_converter import ImageConverter
from file_utils import FileUtils

class ImageProcessor:
    SUPPORTED_FORMATS = {'.png', '.jpeg', '.jpg', '.webp', '.gif'}
    CONVERT_FORMAT = '.heic'

    def __init__(self, target_folder, date_str):
        self.target_folder = os.path.join(target_folder, date_str)
        os.makedirs(self.target_folder, exist_ok=True)

    def process_images(self, photos, openai_client):
        for photo in photos:
            _, ext = os.path.splitext(photo)
            if ext.lower() in self.SUPPORTED_FORMATS:
                target_path = os.path.join(self.target_folder, os.path.basename(photo))
                shutil.copy(photo, target_path)
            elif ext.lower() == self.CONVERT_FORMAT:
                target_path = os.path.join(self.target_folder, os.path.basename(photo).replace(ext, '.jpeg'))
                ImageConverter.convert_to_jpeg(photo, target_path)
            else:
                continue

            if not openai_client.is_food_image(target_path):
                FileUtils.delete_file(target_path)
```

The `OpenAIClient` class will handle communication with the OpenAI API:

openai_client.py
```python
import requests
import base64
import os

class OpenAIClient:
    API_URL = "https://api.openai.com/v1/chat/completions"

    def __init__(self, prompt):
        self.prompt = prompt
        self.api_key = os.getenv("OPENAI_API_KEY")

    def encode_image(self, image_path):
        with open(image_path, "rb") as image_file:
            return base64.b64encode(image_file.read()).decode('utf-8')

    def is_food_image(self, image_path):
        base64_image = self.encode_image(image_path)
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
        payload = {
            "model": "gpt-4-vision-preview",
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": self.prompt
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}"
                            }
                        }
                    ]
                }
            ],
            "max_tokens": 300
        }
        response = requests.post(self.API_URL, headers=headers, json=payload)
        message_text = response.json()['choices'][0]['message']['content']
        return "FOOD" in message_text

```

The `PromptLoader` class will load the prompt from a text file:

prompt_loader.py
```python
class PromptLoader:
    @staticmethod
    def load_prompt(file_path):
        with open(file_path, 'r') as file:
            return file.read().strip()
```

Utility functions for file operations:

file_utils.py
```python
import os

class FileUtils:
    @staticmethod
    def delete_file(file_path):
        os.remove(file_path)
```

Finally, the `requirements.txt` file listing all dependencies:

requirements.txt
```
requests
Pillow
```

This concludes a fully working implementation.